"""events.py

    Module to delegate the games event handling system using pygame. 
    This includes user input and custom events generated by the logic.
    Events are polled at the beginning of each update loop and delegated
    in an Observer-pattern style. EventManager class
    is instantiated only once by game_control.Game and is persistent
    through all game states.
"""

'''
051923 Adding an update method to be called in game_control.Game.update()
        before game_control.Game.curr_state.update() to get user inputs
        and custom events handled first.
       REFACTOR: EventManager.listeners should be private since we have
        a getter func for it.
       During main loop update, event manager should update list of
        listeners, then simply post the event and the listeners will 
        handle them. Therefore, in 
'''


import pygame

import borg
import camera
import constants

from collections import defaultdict



#listeners = {}
'''
def register(ev_type, fn):
    listeners[ev_type].append(fn)

def post(ev_type, data):
    if ev_type in listeners:
        for fn in listeners[ev_type]:
            fn(data)
'''


# PUBLIC INTERFACE -------------------------------------------------------
#listeners_callback = {}
#listeners = {} #{pygame.event.type: [listener<Any>]} listeners must implement .notify() 

#Event Types
ACTION_END = pygame.USEREVENT       #use pygame.event.post(ACTION_END) when an
                                    #  action finishes to get a message to 
                                    #  the eventManager
CHANGE_STATE = pygame.USEREVENT + 1

def register_listener(listener, event_type):
    """Registers the caller(listener) to the event(from event_type) to be
       notified about in the dict(events.listeners). 
       The dict is used by events.EventManager to notify listeners when 
       the event occurs.

    Args:
        listener (_type_): Should implement <object>.notify(event, **kwargs)
        event_type (pygame.event.type) : event types to listen for

    """

    # Get up-to-date dict of registered listeners from EventManager instance
    #ev_listeners = EventManager.listeners

    # Loop through the events were listening for, finding their keys
    #  in the dict and appending the listener to the associated list 
    for event in event_type:
        if event in EventManager.listeners:
            if listener not in EventManager.listeners[event]:
                EventManager.listeners[event].append(listener)
            else:
                print('object tried to double register')
        else:
            EventManager.listeners[event] = [listener]

    print(EventManager.listeners, ' REG\n')

    '''
    for ev in args:
        if ev in ev_listeners:
            if listener not in ev_listeners[ev]:        #no duplicates
                ev_listeners[ev].append(listener)
            else:
                raise Exception("Listener tried to double register")
        else:
            #make new entry
            ev_listeners[ev] = listener
    '''

def register_callback(listener, event, callback):
    """Registers the caller(listener) to the events(*args) to be
       notified about in the dict(events.listeners). 
       The dict is used by events.EventManager to notify listeners when 
       the event occurs.

    Args:
        listener (_type_): Should implement <object>.notify(event, **kwargs)
        args (Any)       : event types to listen for

    """

    # Get up-to-date dict of registered listeners from EventManager instance

    # Loop through the events were listening for, finding their keys
    #  in the dict and appending the listener to the associated list 
    if event in listeners_callback:
        if listener not in listeners_callback[event][0]:        #no duplicates
            listeners_callback[event].append((listener, callback))
        else:
            raise Exception("Listener tried to double register")
    else:
        #make new entry
        listeners_callback[event] = [(listener, callback)]

def unregister_listener(listener, *event_type):
    for ev in event_type:
        if ev in EventManager.listeners:
            if listener in EventManager.listeners[event_type]:
                EventManager.listeners[event_type].remove(listener)
                if EventManager.listeners[event_type] == []:
                    del EventManager.listeners[event_type]
            else: print('listener not registered for the event')
        else: print('the event is not listed')

    print(EventManager.listeners, ' UNREG\n')
        
        
def unregister_callback(listener, *event_type):
    """Unregisters the caller(listener) from the event/s(*args)

    Args:
        listener (_type_)        : Should implement <object>.notify(event, **kwargs)
        args (pygame.event.type) : Events to unregister from
    """
    # Get up-to-date dict of registered listeners from EventManager instance

    # Loop through the events were listening for, finding their keys
    #  in the dict and removing the listener from the associated list 
    for ev in event_type:
        if ev in listeners_callback:
            print(listeners_callback)
            for (lst, cb) in listeners_callback[ev]:
                if listener == lst:
                    #for listeners in listeners_callback.values():
                    print(listeners_callback.values())
                    listeners_callback[ev].remove((lst, cb))
                if not listeners_callback[ev]:
                    del listeners_callback[ev]
        else:
            raise Exception("Listener not registered for the event")
        
def notify(listener, event): pass

#-------------------------------------------------------------------------



class Event:
    """Baseclass for events
    """
    def __init__(self, name='generic'):
        self.name = name


class EventManager(borg.Borg):
    from weakref import WeakKeyDictionary #Use this so unused listeners will be
                                          #   auto unregistered
    listeners = {}       # key(event):value(list(listeners))
    listeners_callback = {}  # key(event): value(list(tuple(listener, callback())))



    def __init__(self):
        super().__init__()

    def get_listeners(self):
        return self.listeners

    #----------------------------------------------------------------------
    def update(self):
        """Called in main loop to handle user input and custom events
        """
        #Get a list of listeners
        self.get_events()

    #----------------------------------------------------------------------
    def register_listener(self, listener, event_types=None):
        """Registers the listener with the event_manager.
        
        Arguments:
            listener {class instance} -- Must implement notify()
        
        Keyword Arguments:
            event_types {list[int]} -- List of all event types to listen for (default: {(constants.EV_NONE)})
        """
        if event_types is None: event_types = [constants.EV_NONE]
        self.listeners[ listener ] = event_types

    #----------------------------------------------------------------------
    def Register_listener(self, listener, event_types: pygame.event.event_name=None):
        """Registers the listener and its listen_for list with the 
            event_manager.
        
        Arguments:
            listener {class instance} -- Must implement notify()
        
        Keyword Arguments:
            event_types {list[pygame.event.event_name]} -- List of all event types 
                                                            to listen for 
                                                            (default: {(constants.EV_NONE)})
        """
        if event_types is None: event_types = [constants.EV_NONE]
        self.listeners[ listener ] = event_types

    #----------------------------------------------------------------------
    def unregister_listener(self, listener):
        if listener in self.listeners.keys():
            del self.listeners[ listener ]

    #----------------------------------------------------------------------
    def post(self, event, **info):
        if event in EventManager.listeners:
            for listener in EventManager.listeners[event]:
                if info: #!!!Hack
                    listener.notify(event, event_data = info.get('info'))
                else:
                    listener.notify(event)

        '''
        if event in listeners_callback:
            for listener in listeners_callback[event]:
                listener[0].notify(event)
        '''
        '''
            for listener in list(self.listeners): # PYTHON 3 HACK!!!!!!!!!!!!!!!!
                #NOTE: If the weakref has died, it will be 
                #automatically removed, so we don't have 
                #to worry about it.
                if self.listeners[listener]:
                    if event.id in self.listeners[listener]:
                        stop = listener.notify(event)
                        if stop:
                            break
                else:
                    self.listeners.pop(listener)
        '''

    def get_events(self):
        #CHECK FOR EVENTS------------------------------------------------------------------
        '''
        for event in pygame.event.get():
            if event.type in listeners_callback:
                if event.type == pygame.QUIT:
                    self.post(QuitEvent())
                    return
                if event.type == pygame.MOUSEBUTTONDOWN:
                    the_list = listeners_callback[event.type]
                    for i in the_list:
                        i[1](pygame.mouse.get_pos())
                        #print(listener)
                #if event.type == pygame.U
        '''

        for event in pygame.event.get():
            if event.type in EventManager.listeners:
                if event.type == pygame.QUIT:
                    self.post(event.type)
                    return
                if event.type == pygame.MOUSEBUTTONDOWN:
                    self.post(event.type, info = pygame.mouse.get_pos())
                    continue
                else:
                    self.post(event.type)
                    continue

            if event.type == pygame.KEYDOWN:
                if event.key in EventManager.listeners:
                    self.post(event.key, info = event.type)
                    continue
            if event.type == pygame.KEYUP:
                if event.key in EventManager.listeners:
                    self.post(event.key, info = event.type)
                    continue
                    '''
                    if event.type == pygame.KEYDOWN:
                        self.post(event.type, info = event)
                    if event.type == pygame.KEYUP:
                        self.post(event.type, info = event)
                    else:
                        self.post(event.type)
                    '''

        '''
        for event in pygame.event.get():

            #Check for QUIT
            if event.type == pygame.QUIT:
                self.post(QuitEvent())
                return 
            
            self.post(event)
        '''
            
        '''
            #Check for Keys---------------------------------------------------
            if event.type == pygame.KEYDOWN:
                #Check for Arrow Keys
                if event.key == pygame.K_LEFT:
                    ev = KeyDown(constants.EV_KEY_LEFT)
                    self.post(ev)
                    break
                    #camera.x_speed = constants.CAM_SPEED
                    #iso_grid.IsoGrid.velocity_x = constants.CAM_SPEED
                elif event.key == pygame.K_RIGHT:
                    ev = KeyDown(constants.EV_KEY_RIGHT)
                    self.post(ev)
                    break
                    #camera.x_speed = -constants.CAM_SPEED
                    #iso_grid.IsoGrid.velocity_x = -constants.CAM_SPEED

                if event.key == pygame.K_UP:
                    ev = KeyDown(constants.EV_KEY_UP)
                    self.post(ev)
                    break
                    #camera.y_speed = constants.CAM_SPEED
                    #iso_grid.IsoGrid.velocity_y = constants.CAM_SPEED
                elif event.key == pygame.K_DOWN:
                    ev = KeyDown(constants.EV_KEY_DOWN)
                    self.post(ev)
                    break
                    #camera.y_speed = -constants.CAM_SPEED
                    #iso_grid.IsoGrid.velocity_y = -constants.CAM_SPEED

            if event.type == pygame.KEYUP:
                if event.key == pygame.K_LEFT:
                    ev = KeyUp(constants.EV_KEY_LEFT_UP)
                    self.post(ev)
                    break
                    #camera.x_speed = 0
                    #iso_grid.IsoGrid.velocity_x = 0
                elif event.key == pygame.K_RIGHT:
                    ev = KeyUp(constants.EV_KEY_RIGHT_UP)
                    self.post(ev)
                    break
                    #camera.x_speed = 0
                    #iso_grid.IsoGrid.velocity_x = 0

                if event.key == pygame.K_UP:
                    ev = KeyUp(constants.EV_KEY_UP_UP)
                    self.post(ev)
                    break
                    #camera.y_speed = 0
                    #iso_grid.IsoGrid.velocity_y = 0
                elif event.key == pygame.K_DOWN:
                    ev = KeyUp(constants.EV_KEY_DOWN_UP)
                    self.post(ev)
                    break
                    #camera.y_speed = 0
                    #iso_grid.IsoGrid.velocity_y = 0

            # Check for clicks------------------------------------------------
            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = pygame.mouse.get_pos()
                ev = MouseEvent(pos)
                self.post(ev)
                break
        '''


# EVENT TYPES -------------------------------------------------------------------------------
class ActionEnd(Event):
    def __init__(self):
        self.id = constants.EV_ACTION_END

class AgentClick(Event):
    def __init__(self, agent_id):
        self.id = agent_id

class KeyDown(Event):
    def __init__(self, key_id):
        self.id = key_id


class KeyUp(Event):
    def __init__(self, key_id):
        self.id = key_id


class MouseEvent(Event):
    def __init__(self, mouse_pos):
        self.pos = mouse_pos
        self.id = constants.EV_MOUSE_CLICK

class CameraMove(Event):
    def __init__(self, offset):
        """Triggered when camera is moved by means other than pressing arrow keys.
        
        Arguments:
            Event {class} -- base class for all events
            offset {tuple(int)} -- change in cam.pos (x, y)
        """
        self.id = constants.EV_CAM_MOVE
        self.offset = offset
        
class QuitEvent(Event):
    """
    Quit event.
    """    
    def __init__(self):
        self.id = constants.EV_QUIT


